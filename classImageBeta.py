"""
performs logistic regression on input images
tries to tell positively labelled images apart from negatively labelled images

contains:

    learnImage
    testAll
    testSingle
    loadTrainingData
    saveResults
    loadResults
    buildTrainingExampleArray
    classifyImage

"""

import os
import numpy as np
import cv2 as cv
import logReg


# =========================== GLOBAL CONSTANTS ================================== #

IMAGE_TYPE = 'betDigit'
DATA_LOCATION = 'elementLibrary/processed/'
SAVE_DATA = True

# =============================================================================== #

def learnImage():
    """
    one vs all classification for binary images
    this algorithm classifies images based on the sum of binary column pixels for each column and row of the image
    images must have already been proccessed RGB->binary->RGB
    this script assumes that every category fed to the algorithm has useful data in it
    """
    
    imageSpecs = ImageSpecs(IMAGE_TYPE) 

    # fill training matrices with labelled image data
    for indexCat in range(imageSpecs.numCat):

        # load data for this category
	dataName = imageSpecs.catNames[indexCat]

	(exampleArr,outcomeArr,numTrainEx) = loadTrainingData(imageSpecs,indexCat)

        # logistic regression - one vs.all
        print 'start logistic regression...'
        (exampleArrNorm, muArr, sigmaArr) = logReg.featureNormalize(exampleArr)
        theta = logReg.logisticRegression(exampleArrNorm,outcomeArr)
        print '... finished'
        
	# test results
        correct = testSingle(exampleArrNorm,outcomeArr,theta,muArr,sigmaArr)
	print 'hypothesis generated by logistic regression produces ',correct,' percent \ncorrect classifications of training data'

	# save training data and results for this category
        if SAVE_DATA:
	    saveArr = np.zeros((numTrainEx,imageSpecs.numFeat+1))
	    saveArr[:,0:imageSpecs.numFeat]    = exampleArr.copy()
	    saveArr[:,imageSpecs.numFeat]      = outcomeArr.copy()
	    saveName = IMAGE_TYPE+dataName+'Data.csv'
	    np.savetxt(saveName,saveArr,delimiter=',')
	    print 'training data saved to ',saveName

	    # save regression results to .csv file
            saveName = IMAGE_TYPE+dataName+'Theta.csv'
            comments = 'theta values for '+dataName
	    results = (theta,muArr,sigmaArr)
	    saveResults(saveName,imageSpecs,comments,results)

    # collate data from each category into a single file
    if SAVE_DATA:
	collateResults(IMAGE_TYPE,imageSpecs)

    # test results for all categories
    testAll(IMAGE_TYPE)

# =============================================================================== #

def collateResults(imageType,imageSpecs):
    # initialise save matrices
    theta   = np.zeros((imageSpecs.numFeat+1,imageSpecs.numCat))
    mu      = theta.copy()
    sigma   = theta.copy()
     # load parameters from each category
    for c in range(imageSpecs.numCat):
        readName    = imageType+imageSpecs.catNames[c]+'Theta.csv'
	(numCat,numFeat_c,dataType,catNames_c,theta_c,mu_c,sigma_c) = loadResults(readName) 
        theta[:,c]  = theta_c
        mu[:,c]     = mu_c 
        sigma[:,c]  = sigma_c
    results = (theta,mu,sigma)
    # save collated parameters to .csv file
    saveName = imageType+'Theta.csv'
    comments = 'collated theta values'
    saveResults(saveName,imageSpecs,comments,results)

# =============================================================================== #

class ImageSpecs:
    def __init__(self,image_type):
    	"""
    	loads and returns image specs from .csv file
    	"""
        location = './classifyImageInfo/'
        fileName = image_type+'.csv'
        DIR = os.path.normpath(location+fileName)

        specs = np.genfromtxt(DIR, delimiter=',',dtype=str)
        print 'debug'
        print specs

        self.dataLocation   = DATA_LOCATION + image_type+'/'
        self.numRow	        = int(specs[2])
        self.numCol	        = int(specs[3])
        self.numCat	        = int(specs[4])
        self.catNames	    = specs[5:].astype(str)
        self.numFeat	    = self.numRow+self.numCol
      

# =============================================================================== #

def testAll(dataType):
    """
    tests one vs all classification over all categories
    """
    
    # load all theta values
    readName = dataType+'Theta.csv'
    (numCat,numFeat,dataType,catNames,theta,mu,sigma) = loadResults(readName,loadForClassify=True)
    n = numFeat

    print theta.shape,mu.shape
    
    for i in range(numCat):
        # load labelled digit data
        saveName = dataType+catNames[i]+'Data.csv'
        digitData = np.genfromtxt(saveName, delimiter=',')
	m = digitData.shape[0]
        # get X, y from data
        X = digitData[:,:(n)]
        y = digitData[:,(n)]
        # add Xo = 1 into X
	Xcalc       = np.zeros((m,n+1)) 
        Xcalc[:,1:] = X.copy()
        Xcalc[:,0]  = 1

        # normalise X
        Xcalc = (Xcalc - mu[:,i]) / sigma[:,i]

        # generate hypothesis for each training example
        yCalcArr = np.zeros((m,numCat))
        for j in range(numCat):
            yCalcRaw        = np.dot(Xcalc,theta[:,j])
            yCalcArr[:,j]   = logReg.sigmoid(yCalcRaw)
        yCalc = np.zeros(m)
        for j in range(m):
            bestEst = np.where(yCalcArr[j,:]==max(yCalcArr[j,:]))[0][0]
            if bestEst == i:
                yCalc[j] = 1
            else:
                yCalc[j] = 0
        
        # compare calc Y to empirical Y
        correct = 100*(yCalc==y).sum()/float(m)
        print 'category',catNames[i]       
        print 'hypothesis generated by logistic regression produces ',correct,' percent \ncorrect classifications of training data'


# =============================================================================== #

def testSingle(exampleArr,outcomeArr,theta,muArr,sigmaArr):
    """
    tests that classification of training array using hypothesis(theta)
    produces the same outcomes as the outcome array
    """
    # don't you have to normalise this 1st?
    outcomeCalcRaw = np.dot(exampleArr,theta)
    outcomeCalc = logReg.sigmoid(outcomeCalcRaw)
    outcomeCalc[outcomeCalc>0.5] = 1
    outcomeCalc[outcomeCalc<=0.5] = 0
    numTrainEx = float(exampleArr.shape[0])
    correct = 100*(outcomeCalc==outcomeArr).sum()/numTrainEx
    return correct

# =============================================================================== #


def loadTrainingData(imageSpecs,categoryIndex):
    """
    populates X and y matrix for logistic regression
    loads data from input folderName using n features
    """

    dataName = imageSpecs.catNames[categoryIndex]

    # ===== get training examples ===== #

    # get positive training examples
    folderNamePos = dataName
    DIRpos = os.path.normpath(imageSpecs.dataLocation+folderNamePos)
    imageListPos = [name for name in os.listdir(DIRpos)if os.path.isfile(os.path.join(DIRpos, name))]
    numExamplesPos = len(imageListPos)

    # get all negative training examples
    if categoryIndex == 0:
	categoryRangeNeg = range(1,imageSpecs.numCat)
    elif categoryIndex == imageSpecs.numCat-1:
        categoryRangeNeg = range(0,imageSpecs.numCat-1)
    else:
	categoryRangeNeg = range(0,categoryIndex)+range(categoryIndex+1,imageSpecs.numCat)

    imageListNeg = [None for x in categoryRangeNeg]
    numExamplesNeg  = [None for x in categoryRangeNeg]
    indexNeg = 0
    for categoryNeg in categoryRangeNeg:
	DIRneg = os.path.normpath(imageSpecs.dataLocation+imageSpecs.catNames[categoryNeg])
	imageListNeg[indexNeg] = [name for name in os.listdir(DIRneg)if os.path.isfile(os.path.join(DIRneg, name))]
        numExamplesNeg[indexNeg] = len(imageListNeg[indexNeg])
        indexNeg += 1

    # total number of training examples
    numTrainEx = numExamplesPos +  sum(numExamplesNeg)    
       
    print numTrainEx,'training examples'
    print 'with',numExamplesPos,'positive and',sum(numExamplesNeg),'negative examples'
    

    # initialize calculation matrices
    exampleArr = np.zeros((numTrainEx,imageSpecs.numFeat))  # input examples for training
    outcomeArr = np.zeros(numTrainEx)			    # output examples for training

    # fill calculation matrices with image data
        
    # load positive example features from positive example images
    for index in range(numExamplesPos):
        imageName = imageListPos[index] 
        outcomeArr[index] = 1                   
        readPath = os.path.normpath(DIRpos+'/'+imageName)  
        imgArrRGB = cv.imread(readPath,1) # assume RGB image has been processed already            
        exampleArr[index,:] = buildTrainingExampleArray(imgArrRGB,imageSpecs)
        
    # for each negative category, load negative example features from negative example images
    row = numExamplesPos # start count from here
    for indexCat in range(imageSpecs.numCat-1):
        folder = categoryRangeNeg[indexCat]
        DIRneg = os.path.normpath(imageSpecs.dataLocation+imageSpecs.catNames[folder])
        for indexNeg in range(numExamplesNeg[indexCat]):
            imageName = imageListNeg[indexCat][indexNeg] 
            outcomeArr[row] = 0
            readPath = os.path.normpath(DIRneg+'/'+imageName)
            imgArrRGB = cv.imread(readPath,1) # assume RGB image has been processed already 
            exampleArr[row,:] = buildTrainingExampleArray(imgArrRGB,imageSpecs)
            row +=1

    return exampleArr,outcomeArr,numTrainEx

# =============================================================================== #

def saveResults(saveName,imageSpecs,comments,results):
    """
    save results of logistic regressions to .csv file
    should work for 1 category as well as 3+ - there should never be 2 categories
    INPUTS:
        saveName    - name to be saved eg. 'digit0.csv' - must include the .csv
        numCat      - number of categories to be sorted, must be at least 1
        numFeat     - number of features, ie. length of theta, includes bias, is effectively n+1
        dataType    - the data type being classified
        catNames    - list of names of each category ['name1','name2',etc...]
        comments    - string of commments for user to inspect
        theta       - numpy array of theta values with dimension numFeat x numCat
        mu          - numpy array of mu values with dimension numFeat x numCat
        sigma       - numpy array of sigma values with dimension numFeat x numCat
    """

    theta	= results[0]
    muArr	= results[1]
    sigmaArr	= results[2]

    # matrix to be saved
    theta_feat = theta.shape[0]
    if theta.ndim > 1:
	theta_cat = theta.shape[1]
	saveArr = np.zeros((theta_feat,theta_cat*3))
    else:
	theta_cat = 1
	saveArr = np.zeros((theta_feat,3))

    # prepare header
    header = comments+'\nnumCat,'+str(imageSpecs.numCat)+'\nnumFeat,'+str(imageSpecs.numFeat)+'\ndataType,'+IMAGE_TYPE+'\ncatNames'
    for cat in imageSpecs.catNames:
        header = header+','+cat
    header = header+'\ntheta 1'
    for name in ['theta ','mu ','sigma ']:
        for i in range(1,theta_cat+1):
            if i == 1 and name == 'theta ':
                continue
            header = header +','+ name+str(i)


    # collate category parameters
    if theta.ndim == 1:
        saveArr[:,0]  = theta
        saveArr[:,1]  = muArr
        saveArr[:,2]  = sigmaArr
    else:
        saveArr[:,0:theta_cat]			= theta
        saveArr[:,theta_cat:2*theta_cat]	= muArr
        saveArr[:,2*theta_cat:3*theta_cat]	= sigmaArr
    # save collated parameters to .csv file
    np.savetxt(saveName,saveArr,delimiter=',',header=header)
    print 'theta values saved to ',saveName

# =============================================================================== #

def loadResults(readName,loadForClassify=False):
    """
    loads parameters for a logistic regression from a .csv file saved using saveResults
    returns parameters
    """

    results = np.genfromtxt(readName, delimiter=',')
    
    # ===== get descriptive data ===== #
    
    #print 'loading parameter file:',readName
    header = open(readName)
    header.readline()#print 'file comment:\t',header.readline()[2:]
    numCat          = int(header.readline()[2:].split(',')[1])
    numFeat	        = int(header.readline()[2:].split(',')[1])
    dataType	    = header.readline()[2:].split(',')[1]
    catNames	    = header.readline()[2:].split(',')[1:]
    dataType	    = dataType[:-1]	# get rid of \n at end
    catNames[-1]    = catNames[-1][:-1] # get rid of \n at end
    
    # ===== get theta, mu, sigma ===== #
    if loadForClassify:
        theta   = np.zeros((numFeat,numCat)) # it looks like digitTheta.csv in learning data includes bias in numFeat
        mu      = np.zeros((numFeat,numCat))
        sigma   = np.zeros((numFeat,numCat))
        for c in range(numCat):
            print readName
            theta[:,c]  = results[:,c] 
            mu[:,c]     = results[:,c + numCat] 
            sigma[:,c]  = results[:,c + 2*numCat]
    else:
        theta   = np.zeros(numFeat)
        mu      = np.zeros(numFeat)
        sigma   = np.zeros(numFeat)
    
        theta  = results[:,0] 
        mu     = results[:,1] 
        sigma  = results[:,2]

    return numCat,numFeat,dataType,catNames,theta,mu,sigma

# =============================================================================== #

def buildTrainingExampleArray(imgArr,imageSpecs,isRGB=True):
    """
    builds the training matrix X
    """

    numCol = imageSpecs.numCol
    numRow = imageSpecs.numRow

    # builds a single row of X - ie, one input
    if isRGB:
	imgArr = imgArr[:,:,0]
        imgArr[imgArr>0] = 1
    print numCol,numRow # -1 -1 ? where do these come from?
    X = np.zeros(numCol+numRow)
    # load features
    for col in range(numCol):
	X[col] = imgArr[:,col].sum()
    for row in range(numRow):
	feat = numCol+row
        X[feat] = imgArr[row,:].sum()
    return X

# =============================================================================== #

def classifyImage(imgArr,imgType,parameterName):
    """
    does one vs all classification only
    currently only works for digits
    will have to add suits too
    consider adding this info to parameter files so that this can be automated more simply
    """

    imageSpecs = ImageSpecs(imgType) 

    #numCol = imageSpecs.numCol
    #numRow = imageSpecs.numRow
   
    # load hypothesis function (theta values)
    path    = os.path.normpath('learningData/'+parameterName)
    (numCat,numFeat,dataType,catNames,theta,mu,sigma) = loadResults(path,loadForClassify=True)

    # get X (input data for classfication) from image data
    #X = buildTrainingExampleArray(imgArr,dataType,numCol,numRow,isRGB=False)
    X = buildTrainingExampleArray(imgArr,imageSpecs,isRGB=False)
    
    # add Xo = 1 into X
    Xcalc       = np.zeros(numFeat) 
    Xcalc[1:]   = X.copy()
    Xcalc[0]    = 1
    yCalcArr    = np.zeros(numCat)

    # generate hypothesis for each digit
    for i in range(numCat): 
        # normalise X
        XcalcCat = (Xcalc - mu[:,i]) / sigma[:,i]

        # generate hypothesis
        yCalcRaw        = np.dot(XcalcCat,theta[:,i])
        yCalcArr[i]     = logReg.sigmoid(yCalcRaw)
        
    bestEst = np.where(yCalcArr==yCalcArr.max())[0][0]
    catEst = catNames[bestEst]
    #print yCalcArr
    #print 'best estimate index',bestEst,'classifies digit as',catEst
    return catEst

# =============================================================================== #

# run main
if __name__ == '__main__':
    learnImage()
# =============================================================================== #







